import Foundation

enum PreviewLoader {}

extension PreviewLoader {
    enum Keys {
        static let viewMarkerStart = "        DeveloperToolsSupport"
        static let viewMarkerEnd = "    }"

        static let prefireDisableMarker = ".prefireIgnored()"

        static let source = "// original-source-range: "
        static let fileType = "_.swift"

        static let macroType = "fMf" // freestanding macro
        static let macroName = "Preview" + macroType
    }
    
    /// Path to the directory with the generated macro files for preview
    ///
    /// For example: 'file:///var/folders/zd/.../T/swift-generated-sources/'
    static let previewMacrosDirectory = FileManager.default.temporaryDirectory.appending(path: "swift-generated-sources")

    static func loadRawPreviewBodies(for target: String, and sources: String) -> [String]? {
        let fileURLs = try? FileManager.default.contentsOfDirectory(at: previewMacrosDirectory, includingPropertiesForKeys: nil)

        var previewMacroBodies = [String]()

        for fileURL in fileURLs ?? [] {
            var fileName = fileURL.lastPathComponent
            // Remove unnecessary identifiers
            fileName = fileName.components(separatedBy: .decimalDigits).joined()
            guard fileName.hasSuffix(Keys.macroName + Keys.fileType) else { continue }

            if let previewBody = loadPreviewBody(from: fileURL, and: sources), !previewMacroBodies.contains(previewBody) {
                previewMacroBodies.append(previewBody)
            }
        }

        guard !previewMacroBodies.isEmpty else { return nil }

        return previewMacroBodies
    }
    
    /// Loading the preview body using the passed URL
    /// - Parameters:
    ///   - fileURL: URL to the preview file generated by the macro
    ///   - sources: URL to sources to validate that these previews belong to the desired project
    /// - Returns: PreviewBody - `DeveloperToolsSupport.Preview { EmptyView() }`
    static func loadPreviewBody(from fileURL: URL, and sources: String) -> String? {
        guard let content = try? String(contentsOf: fileURL, encoding: .utf8), !content.isEmpty else { return nil }

        var lines = content.components(separatedBy: .newlines)
        lines.removeLast()

        guard lines.last?.hasPrefix(Keys.source + sources) == true else { return nil }

        var result = ""
        var isInsideFunction = false

        for line in lines {
            if line.hasPrefix(Keys.viewMarkerStart) {
                isInsideFunction = true
            } else if line.hasPrefix(Keys.viewMarkerEnd) {
                isInsideFunction = false
                result.removeLast()
            }

            if line.hasSuffix(Keys.prefireDisableMarker) {
                return nil
            }

            if isInsideFunction {
                result += line + "\n"
            }
        }

        guard checkAvailability(for: lines.last, and: result.components(separatedBy: .newlines)) else { return nil }

        return result + "\n"
    }
    
    /// Checking the relevance and availability of the code on the basis of which the macro for Previews was developed
    /// - Parameters:
    ///   - lastLine: The last line of the macro file containing the path to the source file. Example: `some.swift:22:1-24:2"`
    ///   - result: The result of the macro preview
    static func checkAvailability(for lastLine: String?, and result: [String]) -> Bool {
        guard let line = lastLine?.replacingOccurrences(of: Keys.source, with: "") else { return false }

        var components = line.components(separatedBy: ":")
        components.removeLast(2)
        guard let firstLine = Int(components.removeLast()) else { return false }

        guard let path = components.first, let fileURL = URL(string: "file://" + path),
              let content = try? String(contentsOf: fileURL, encoding: .utf8), !content.isEmpty else { return false }

        let lines = content.components(separatedBy: .newlines)
        var result = result
        // Remove `DeveloperToolsSupport.Preview`
        result.removeFirst()
        // Remove `}`
        result.removeLast()

        // We compare the macro file and the source file line by line
        for i in 0..<result.count {
            guard let left = result[safe: i]?.trimmingCharacters(in: .whitespaces),
                  let right = lines[safe: firstLine + i]?.trimmingCharacters(in: .whitespaces),
                    left == right else { return false }
        }

        return true
    }
}

extension Collection {
    subscript(safe index: Index) -> Element? {
        get {
            return indices.contains(index) ? self[index] : nil
        }
    }
}
