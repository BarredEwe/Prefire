import Foundation

/// Simplify and improve the process of locating and parsing generated preview code for Swift projects.
enum PreviewLoader {
    enum Keys {
        static let viewMarkerStart = "        DeveloperToolsSupport"
        static let viewMarkerEnd = "    }"

        static let prefireDisableMarker = ".prefireIgnored()"
        static let prefireEnabledMarker = ".prefireEnabled()"

        static let source = "// original-source-range: "
        static let fileType = "_.swift"

        static let macroType = "fMf" // freestanding macro
        static let macroName = "Preview" + macroType

        static let generatedSourcesDirectory = "swift-generated-sources"
    }

    /// Path to the directory where generated macro files for preview are stored
    ///
    /// For example: 'file:///var/folders/zd/.../T/swift-generated-sources/'
    static let previewMacrosDirectory = FileManager.default.temporaryDirectory.appending(path: Keys.generatedSourcesDirectory)

    /// Attempts to locate raw preview bodies within the specified sources string and returns them as an array of Strings.
    /// - Parameters:
    ///   - target: A specific identifier (e.g., a product name or bundle ID) used to filter relevant macros during search.
    ///   - sources: Raw Swift sources represented as a single multi-line string.
    ///   - defaultEnabled: Whether automatic view inclusion should be allowed. Default value is true.
    /// - Returns: Array of Strings, possibly empty but never null; if no suitable match found
    static func loadRawPreviewBodies(for target: String, and sources: String, defaultEnabled: Bool) -> [String]? {
        let fileURLs = try? FileManager.default.contentsOfDirectory(at: previewMacrosDirectory, includingPropertiesForKeys: nil)

        var previewMacroBodies = [String]()

        for fileURL in fileURLs ?? [] {
            var fileName = fileURL.lastPathComponent
            // Remove unnecessary identifiers
            fileName = fileName.components(separatedBy: .decimalDigits).joined()
            // Filter out non-matching filenames
            guard fileName.hasSuffix(Keys.macroName + Keys.fileType) else { continue }

            if let previewBody = loadPreviewBody(from: fileURL, and: sources, defaultEnabled: defaultEnabled), !previewMacroBodies.contains(previewBody) {
                previewMacroBodies.append(previewBody)
            }
        }

        guard !previewMacroBodies.isEmpty else { return nil }

        return previewMacroBodies
    }

    /// Loading the preview body using the passed URL
    /// - Parameters:
    ///   - fileURL: URL to the preview file generated by the macro
    ///   - sources: URL to sources to validate that these previews belong to the desired project
    ///   - defaultEnabled: Automatic view addition is enabled
    /// - Returns: PreviewBody - `DeveloperToolsSupport.Preview { EmptyView() }`
    static func loadPreviewBody(from fileURL: URL, and sources: String, defaultEnabled: Bool) -> String? {
        guard let contents = try? String(contentsOfFile: fileURL.path), !contents.isEmpty else {
            print("⚠️ Cannot load file with Preview macro at path: \(fileURL.path)")
            return nil
        }

        var lines = contents.components(separatedBy: .newlines)
        lines.removeLast()

        guard lines.last?.hasPrefix(Keys.source + sources) == true else { return nil }

        var result = ""
        var isInsideFunction = false
        var viewMustBeLoaded = defaultEnabled

        for line in lines {
            if line.hasPrefix(Keys.viewMarkerStart) {
                isInsideFunction = true
            } else if isInsideFunction, line.hasPrefix(Keys.viewMarkerEnd) {
                isInsideFunction = false
                result.removeLast()
            }

            if defaultEnabled {
                if line.hasSuffix(Keys.prefireDisableMarker) {
                    return nil
                }
            } else if !viewMustBeLoaded {
                viewMustBeLoaded = line.hasSuffix(Keys.prefireEnabledMarker)
            }

            if isInsideFunction {
                result += line + "\n"
            }
        }

        guard viewMustBeLoaded, checkAvailability(for: lines.last, and: result.components(separatedBy: .newlines)) else { return nil }

        return result + "\n"
    }

    /// Checks the relevance and availability of the code on the basis of which the macro for Previews was developed
    /// - Parameters:
    ///   - lastLine: The last line of the macro file containing the path to the source file. Example: `some.swift:22:1-24:2`
    ///   - result: An array representing the results of the macro preview without the initial `DeveloperToolsSupport.Preview` and final `}`.
    static func checkAvailability(for macroFileLastLine: String?, and result: [String]) -> Bool {
        guard let lastLine = macroFileLastLine?.replacingOccurrences(of: Keys.source, with: "") else { return false }

        var splitComponents = lastLine.components(separatedBy: ":")
        splitComponents.removeLast(2)
        guard let firstLine = Int(splitComponents.removeLast()) else { return false }

        guard let path = splitComponents.first, let fileURL = URL(string: "file://" + path),
              let content = try? String(contentsOf: fileURL, encoding: .utf8), !content.isEmpty else { return false }

        let lines = content.components(separatedBy: .newlines)
        var result = result
        // Remove `DeveloperToolsSupport.Preview`
        result.removeFirst()
        // Remove `}`
        result.removeLast()

        // We compare the macro file and the source file line by line
        for i in 0..<result.count {
            guard let left = result[safe: i]?.trimmingCharacters(in: .whitespaces),
                  let right = lines[safe: firstLine + i]?.trimmingCharacters(in: .whitespaces),
                    left == right else { return false }
        }

        return true
    }
}

extension Collection {
    subscript(safe index: Index) -> Element? {
        get {
            return indices.contains(index) ? self[index] : nil
        }
    }
}
